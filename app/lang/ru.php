<?php

return [
    'app.name' => 'AI для PHP-разработчиков (примеры)',
    'app.name_short' => 'AI для PHP-разработчиков',

    'nav.home' => 'Главная',
    'nav.introduction' => 'Введение',
    'nav.getting_started' => 'С чего начать',
    'nav.code_example' => 'Пример кода',
    'nav.code_run' => 'Запускаем код',
    'nav.part1_title' => 'Часть I. Математический язык ИИ',
    'nav.part1_what_is_model' => 'Что такое модель',
    'nav.part1_function_as_the_model' => 'Функция как основа модели',
    'nav.part1_error_as_measure_of_quality' => 'Ошибка как мера качества',
    'nav.part1_vectors' => 'Векторы, размерности и пространства признаков',
    'nav.part1_distances' => 'Расстояния и сходство',
    'nav.part2_title' => 'Часть II. Обучение как оптимизация',
    'nav.part2_error_loss_functions' => 'Ошибка, loss-функции и почему они нужны',
    'nav.part2_apartment_valuation_based_on_parameters' => 'Оценка стоимости квартиры по параметрам',

    // Часть III: навигация
    'nav.part3_title' => 'Часть III. Классификация и вероятности',
    'nav.part3_probability_confidence' => 'Вероятность как степень уверенности',
    'nav.part3_softmax_example' => 'Пример вероятности с softmax',

    'home.title' => 'Главная',
    'home.heading' => 'С чего начать',
    'home.intro' => 'Это примеры к книге по "AI для PHP-разработчиков".',
    'home.official_site' => 'Официальный сайт',
    'home.official_repo' => 'Официальный репозиторий',
    'home.all_examples' => 'Все примеры кода написаны на PHP v8.2',

    'home.disclaimer_title' => 'Отказ от ответственности',
    'home.disclaimer_p1' => 'Примеры кода, приведённые в книге "ИИ для PHP-разработчиков", предназначены только для учебных целей. Они демонстрируют концепции и техники искусственного интеллекта и машинного обучения на PHP. Эти примеры не предназначены для промышленной эксплуатации и не должны использоваться на боевых серверах или в системах, работающих с конфиденциальными данными.',
    'home.disclaimer_p2' => 'Демонстрационный код не проходил полноценное тестирование на безопасность и может содержать неточности, уязвимости, неэффективные решения и другие проблемы, которые могут представлять риск при использовании в продакшене. Он может быть не на 100% точен и не всегда соответствовать лучшим практикам. Перед использованием таких решений в реальных приложениях настоятельно рекомендуется их тщательно проверить, протестировать и обезопасить.',
    'home.disclaimer_p3' => 'Автор и издатель не несут ответственности за какие-либо инциденты безопасности, потерю данных или другие убытки, которые могут возникнуть при использовании этих примеров на боевых серверах.',

    'common.copy' => 'копировать',
    'common.copied' => 'Cкопировано!',
    'common.example_of_use' => 'Пример использования',
    'common.run_code' => 'Запустить код',
    'common.show_code' => 'Показать код',
    'common.click_to_collapse' => 'Нажмите, чтобы свернуть',
    'common.click_to_expand' => 'Нажмите, чтобы развернуть',
    'common.collapse' => 'Свернуть',
    'common.expand' => 'Развернуть',
    'common.result' => 'Результат',
    'common.memory' => 'Память',
    'common.time' => 'Время',
    'common.time_running' => 'работы',
    'common.seconds_short' => 'сек.',
    'common.charts' => 'Графики',
    'common.regenerate' => 'Сгенерировать заново',
    'common.implementation_in_pure_php' => 'Реализация на чистом PHP',
    'common.debug' => 'Дебаг',
    'common.debug_traceback' => 'Трассировка отладки',
    'common.show_debug' => 'Показать дебаг',
    'common.open_in_full_screen' => 'Открыть в полноэкранном режиме',
    'common.git_repository' => 'GitHub Репозиторий',
    'common.back' => 'Назад',

    // Экосистема ML в PHP (intro)
    'ml_ecosystem.title' => 'Экосистема ML в PHP',
    'ml_ecosystem.breadcrumb' => 'Экосистема ML в PHP',
    'ml_ecosystem.sample_phpml_title' => 'Пример на PHP-ML',
    'ml_ecosystem.sample_rubix_title' => 'Пример на RubixML',
    'ml_ecosystem.examples_heading' => 'Учебные примеры',
    'ml_ecosystem.examples_intro' => 'Эти примеры помогут вам понять, как можно использовать ML в PHP. Они не являются полноценными приложениями, но помогут вам понять основы работы с ML в PHP.',
    'ml_ecosystem.rubix_intro' => 'Rubix поддерживает классификацию, регрессию, кластеризацию и работу с датасетами как с first-class объектами. Посмотрим, как это выглядит на практике. Допустим, у нас есть данные для бинарной классификации:',
    'ml_ecosystem.phpml_intro' => 'Типичный сценарий: у вас есть признаки из базы данных, вы хотите быстро обучить модель для классификации или регрессии, сохранить ее и использовать в runtime без внешних сервисов. Пример выглядит почти учебно:',

    'what_is_model.heading' => 'Что такое модель в математическом смысле',
    'what_is_model.function_as_basis_of_model' => 'Функция как основа модели',
    'what_is_model.error_as_measure_of_quality' => 'Ошибка как мера качества',
    'what_is_model.description1' => 'Допустим, мы хотим предсказывать цену квартиры по ее площади. В простейшем случае модель можно взять линейную: $ŷ = w x + b$ <br><br>Это уже полноценная модель. Она говорит: "Цена ($ŷ$) приблизительно равна площади ($x$), умноженной на некоторый коэффициент ($w$), плюс некоторое смещение ($b$)". <br><br>Если переписать это на PHP, получится почти тривиальный код:',
    'what_is_model.description2' => 'Предсказание цены квартиры по ее площади. Используем линейную функцию: $ŷ = w x + b$',
    'what_is_model.explanation_simple' => 'Пояснение: $2 * 3 + 0 = 6$ <br>По формуле: $ŷ = 2 x + b$',
    'what_is_model.intro' => 'Когда мы говорим о модели в машинном обучении, полезно сразу отбросить все ассоциации с "искусственным интеллектом" и сложными абстракциями. В математическом смысле модель — это функция: она принимает входные данные и возвращает результат. Главное отличие в том, что такая функция не жёстко задана раз и навсегда, а имеет настраиваемые параметры.',
    'what_is_model.link_function_as_model' => 'Функция как основа модели',
    'what_is_model.link_error_as_quality' => 'Ошибка как мера качества',
    'what_is_model.link_learning_as_min_error' => 'Обучение как минимизация ошибки',
    'what_is_model.error_measure.intro1' => 'Ошибка — это функция (общепринятое название — loss‑функция), которая сравнивает предсказание модели с реальным значением и возвращает число, показывающее, насколько мы ошиблись. Чем меньше это число, тем лучше модель. Например, самая простая ошибка — разница между предсказанием и реальностью: $ŷ - y$.',
    'what_is_model.error_measure.intro2' => 'На практике чаще используют квадрат ошибки (Squared Error или SE), потому что он всегда положительный и сильнее наказывает большие промахи: $(ŷ − y)^2$.',
    'what_is_model.error_measure.explanation' => 'Пояснение: −3 ⇒ 7 − 10 = −3<br>Пояснение: 4 ⇒ (6 − 4)² = 2² = 4',

    'errors_loss.heading' => 'Ошибка, loss-функции и зачем они нужны',
    'errors_loss.intro' => 'Любая модель машинного обучения сводится к простой идее: она пытается приблизить реальность функцией. А значит, между тем, что есть на самом деле, и тем, что говорит модель, всегда будет расхождение. Это расхождение мы и называем ошибкой. Важно сразу понять одну вещь: модель не знает, что такое "хорошо" и "плохо". Она не понимает смысл задачи. Всё, что она умеет — уменьшать число, которое мы ей дали. Это число и есть loss. Формально ошибка — это отклонение между $y$ и $\\hat{y}$, а loss — функция, которая превращает это отклонение в число, удобное для оптимизации.',
    'errors_loss.intro2' => 'Ниже мы разберём несколько коротких, но показательных кейсов на PHP, которые шаг за шагом связывают формулы с реальными задачами:',
    'errors_loss.case1_title' => 'Кейс 1. MSE и цена большого промаха',
    'errors_loss.case1.intro1' => 'Представим сервис оценки стоимости квартир. Ничего сложного: на вход подаётся площадь, на выходе – прогнозируемая цена. Это типичная задача регрессии, и для неё почти автоматически выбирают MSE. Но именно здесь хорошо видно, какую цену мы платим за такой выбор.',
    'errors_loss.case1.intro2' => 'Реализуем MSE буквально в несколько строк, без каких-либо библиотек и затем испортим картину всего одной точкой. Пусть в данных появилась странная квартира: либо ошибка в базе, либо уникальный объект, либо просто неудачный прогноз.',
    'errors_loss.case1.mse_description' => 'MSE — среднеквадратичная ошибка, одна из самых распространённых loss‑функций для задач регрессии. Она измеряет средний квадрат разницы между предсказанием модели и истинным значением:<br><br>$\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2$',
    'errors_loss.case1.explanation' => 'Нормальный MSE: $4$<br>После добавления выброса MSE очень сильно изменился — 4820.<br>Почему так происходит, легко увидеть на уровне одной формулы (по выбросу): $(300 - 130)^2 = 170^2 = 28900$.',
    'errors_loss.case2_title' => 'Кейс 2. Выбор модели через loss-функцию',
    'errors_loss.case3_title' => 'Кейс 3. Log loss и уверенность классификатора',
    'errors_loss.case4_title' => 'Кейс 4. Одинаковая точность — разный log loss',
    'errors_loss.case5_title' => 'Кейс 5. Обучение модели как минимизация ошибки',

    'linear_regression.heading' => 'Линейная регрессия как базовая модель',
    'linear_regression.intro1' => 'Линейная регрессия – это та точка, с которой удобно начинать разговор про машинное обучение. Не потому, что она "простая", а потому, что в ней уже есть почти всё: модель как функция, параметры, ошибка, оптимизация и геометрический смысл. Если понять линейную регрессию, дальше большинство моделей будут восприниматься как её усложнения.',
    'linear_regression.intro2' => 'В следующих кейсах мы будем рассматривать линейную регрессию не как учебный алгоритм, а как инженерный инструмент.',
    'linear_regression.case1_title' => 'Кейс 1. Оценка стоимости квартиры по параметрам',
    'linear_regression.case2_title' => 'Кейс 2. Прогноз времени выполнения задачи разработчиком',
    'linear_regression.case3_title' => 'Кейс 3. Прогноз потребления ресурсов сервера',
    'linear_regression.case4_title' => 'Кейс 4. Оценка вероятного чека клиента',
    'linear_regression.case5_title' => 'Кейс 5. Прогноз зарплаты по рынку',
    'linear_regression.case1.php_impl_intro' => 'Начнём с варианта без библиотек. Это полезно не для продакшена, а для понимания. Мы будем использовать градиентный спуск, матрицу признаков $X$ размером $N$ x $4$ и вектор весов $w$ длины $4$. Bias добавим как дополнительный признак со значением 1.',
    'linear_regression.case1.rubix_impl_title' => 'Реализация на RubixML',
    'linear_regression.case1.rubix_impl_intro' => 'Теперь сделаем то же самое, но так, как это обычно делается в реальных проектах. Используем линейную регрессию методом наименьших квадратов. Здесь библиотека сама решает задачу оптимизации и подбирает веса аналитически.',
    'linear_regression.case1.php_result_intro' => 'В блоке выше показан результат работы скрипта: предсказанная стоимость квартиры по следующим признакам:',
    'linear_regression.case1.feature_area' => 'Площадь квартиры: 60 м²',
    'linear_regression.case1.feature_rooms' => 'Количество комнат: 5',
    'linear_regression.case1.feature_bathrooms' => 'Количество ванных комнат: 4',
    'linear_regression.case1.feature_floors' => 'Количество этажей: 12',
    'linear_regression.case1.feature_bias' => 'Отклонение: 1',

    // Кейс 1: UI графиков (code-run.php)
    'linear_regression.case1.chart_price_vs_area' => 'Цена vs Площадь',
    'linear_regression.case1.chart_price_vs_floor' => 'Цена vs Этаж',
    'linear_regression.case1.chart_price_vs_distance' => 'Цена vs Расстояние до центра',
    'linear_regression.case1.chart_price_vs_age' => 'Цена vs Возраст дома',
    'linear_regression.case1.chart_xlabel_area' => 'Площадь (м²)',
    'linear_regression.case1.chart_xlabel_floor' => 'Этаж',
    'linear_regression.case1.chart_xlabel_distance' => 'Расстояние до центра (км)',
    'linear_regression.case1.chart_xlabel_age' => 'Возраст здания (лет)',
    'linear_regression.case1.chart_ylabel_price' => 'Цена ($)',
    'linear_regression.case1.chart_regression_label' => 'Линия регрессии',
    'linear_regression.case1.controls_chart_type' => 'Тип графика',

    'gradient_descent.heading' => 'Градиентный спуск на пальцах',
    'gradient_descent.implementation' => 'Реализация градиентного спуска',
    'gradient_descent.minimal_example_intro' => 'Начнём с минимального примера: один признак, один вес. Оценка стоимости квартиры по её площади.',
    'gradient_descent.intro1' => 'Градиентный спуск, метод градиентного спуска – численный метод нахождения локального минимума или максимума функции с помощью движения вдоль градиента, один из основных численных методов современной оптимизации.',
    'gradient_descent.intro2' => 'Когда в машинном обучении говорят "обучение модели", почти всегда имеют в виду одно и то же: мы хотим подобрать параметры так, чтобы ошибка стала как можно меньше. Какая именно модель – линейная регрессия, логистическая, нейросеть – не так важно. Важнее то, что за кулисами почти всегда работает один и тот же механизм – градиентный спуск.',
    'gradient_descent.implementation_link' => 'Реализация градиентного спуска',
    'gradient_descent.sample1_title' => 'Пример 1. Траектория параметра',
    'gradient_descent.sample2_title' => 'Пример 2. Влияние learning rate',
    'gradient_descent.sample3_title' => 'Пример 3. Плато и почти нулевой градиент',
    'gradient_descent.sample4_title' => 'Пример 4. Batch и стохастический спуск',
    'gradient_descent.result_hint' => 'Для этих данных результат будет близок к:',
    'gradient_descent.debug_title' => 'Отладка градиентного спуска',
    'gradient_descent.learning_rate' => 'Скорость обучения',
    'gradient_descent.epochs' => 'Эпохи',

    // Часть III: Вероятность как степень уверенности
    'probability_confidence.intro' => 'Когда разработчики слышат слово "вероятность", в голове часто всплывают игральные кости, подбрасывание монетки и школьная формула "благоприятные исходы делить на все возможные". Это полезная, но очень узкая картинка. В машинном обучении и в прикладной аналитике вероятность почти всегда означает другое – степень нашей уверенности в утверждении, исходя из имеющихся данных.',
    'probability_confidence.link_softmax_example' => 'Пример вероятности с softmax',
    'probability_confidence.case1_title' => 'Кейс 1. Фильтр спама: вероятность ≠ решение',
    'probability_confidence.case2_title' => 'Кейс 2. Медицинский тест: обновление уверенности',
    'probability_confidence.case3_title' => 'Кейс 3. Многоклассовая классификация и softmax',
    'probability_confidence.case4_title' => 'Кейс 4. Переуверенная модель как сигнал проблемы',
    'probability_confidence.case5_title' => 'Кейс 5. Обновление уверенности при новых данных',

    'probability_confidence.logits_paragraph' => 'Во многих моделях машинного обучения выходом являются не вероятности, а так называемые оценки (logits). Это просто числа, отражающие относительную уверенность модели в каждом варианте. Они могут быть любыми – положительными, отрицательными, большими или маленькими – и сами по себе не интерпретируются как вероятность. Чтобы превратить такие оценки в корректные вероятности, используется функция softmax.',
    'probability_confidence.softmax_result_explanation' => 'Теперь мы получили корректное распределение вероятностей: каждое значение находится в диапазоне от 0 до 1; сумма всех значений равна 1; числа можно интерпретировать как степень уверенности модели.',
];
